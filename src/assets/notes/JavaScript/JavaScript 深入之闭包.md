## 定义

当函数可以记住并访问所在的词法作用域时，就产生了**闭包**。

> 闭包是基于词法作用域书写代码时所产生的自然结果。

## 分析

举个例子：

```js
function foo() {
	var a = 2;
	
	function bar() {
		console.log(a);
	}
	
	bar();
}

foo();
```

这段代码基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a。

这是闭包吗？

技术上来讲，函数 bar() 具有一个涵盖 foo() 作用域的闭包，但也可以认为 bar() 被封闭在了 foo() 的作用域中。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分）

通过这种方式定义的闭包并不能直接进行观察，我们来看下一段代码，清晰地展示了闭包：

```js
function foo() {
	var a = 2;
	
	function bar() {
		console.log(a);
	}
	
	return bar;
}
var baz = foo();

baz();	// 2	<-- 这就是闭包的效果
```

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。

bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。

拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。